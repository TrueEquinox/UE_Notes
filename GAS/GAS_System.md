# Getting Started

## Add Plugin

Open Unreal Editor, then go to Edit > Plugins and search for "Gameplay Abilities" plugin. Enable it and restart the editor.

## Initialize Character

Go into your game's Build.cs file and add:

        PrivateDependencyModuleNames.AddRange(new string[] { "GameplayAbilities", "GameplayTags", "GameplayTasks" });

Now you need to include the AbilitySystemInterface in your Character class.

        #include "AbilitySystemInterface.h"

You also need to extend the AblitySystemInterface on your character:

        class YOURGAME_API AYourCharacter : public ACharacter, public IAbilitySystemInterface
        {
            ...
        }

## Create Ability System Component

You will need to make your own ability system component, name it whatever you want and be sure to include the AbilitySystemComponent.h header file. This is your specification file.

        #include "AbilitySystemComponent.h"

You will also need to extend the AbilitySystemComponent in the constructor for this class:

        UCLASS()
        class YOURGAME_API UYourAbilitySystemComponent : public UAbilitySystemComponent
        {
            GENERATED_BODY()
        }

## Create Parent Attribute Set

Create your own attribute set. Name it whatever you want just be sure to include the AttributeSet header file and forward declare your AbilitySystemComponent:

        #include "AttributeSet.h"

        class UYourAbilitySystemComponent;

Now create the struct for attribute data and thte constructor and add the following code:

        USTRUCT(BlueprintType)
        struct FYourGameGameplayAttributeData : public FGameplayAttributeData {
            GENERATED_BODY()
        };

        UCLASS()
        class YOURGAME_API UYourAttributeSet : public UAttributeSet
        {
            GENERATED_BODY()

        public:

            UYourAttributeSet();
            UYourAbilitySystemComponent* GetYourAbilitySystemCompoent() const;

        };

Next, go to the implementation file for your attribute set file, YourAttributeSet.cpp. Add the following code:

        #include "YourAttributeSet.h"
        #include "YourAbilitySystemComponent.h"
        
        UYourAttributeSet::UYourAttributeSet() {}

        UYourAbilitySystemComponent* UYourAttributeSet::GetYourAbilitySystemComponent() const 
        {
	        return Cast<UYourAbilitySystemComponent>(GetOwningAbilitySystemComponent());
        }

You will come back here later if you want to setup clamping.

## Create Child Attribute Set

Now you can make your own Attribute set for a certain attribute. I will document here how to setup a basic attribute set for health and stamina. Here is the full file:

        #pragma once

        #include "YourAbilitySystemComponent.h"
        #include "YourAttributeSet.h"
        #include "YourHealthSet.generated.h" # this line is autogenerated

        UCLASS(BlueprintType)
        class YOURGAME_API UYourHealthSet : public UYourAttributeSet 
        {
            GENERATED_BODY()

        public:

            UYourHealthSet();

            ATTRIBUTE_ACCESSORS(UYourHealthSet, Health);
            ATTRIBUTE_ACCESSORS(UYourHealthSet, Stamina);

        private:

            UPROPERTY(BlueprintReadOnly, Category = "YourGame|Health", Meta = (AllowPrivateAccess = true))
            FYourGameplayAttributeData Health;

            UPROPERTY(BlueprintReadOnly, Category = "YourGame|Stamina", Meta = (AllowPrivateAccess = true))
            FYourGameplayAttributeData Stamina;

        };

## Finish Setting up character

Go into to constructor for your character class and before the BeginPlay add the following code:

        UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GAS", meta = (AllowPrivateAccess = "true"))
        class UAbilitySystemComponent* YourAbilitySystemComponent;

        virtual UAbilitySystemComponent* GetAbilitySystemComponent() const {
	        return YourAbilitySystemComponent;
        }

        UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "GAS", meta = (AllowPrivateAccess = "true"))
        const class UYourHealthSet* YourHealthSet;

This is the basic C++ Setup for the gameplay ability system. Now you should be able to use it on your character. If you want to use it on another character you just need to add the same code we added.

# Clamping attributes

## Setup Macros

Clamping your attributes in the code is useful if you want to limit how small and large an attribute can get but also don't want to have to make extra attributes just to keep track of it. First go to your AttributeSet class that you created "YourAttributeSet.h" and add the following code after the includes and forward declarations but before the struct you setup:

        #define GAMEPLAYATTRIBUTE_MAXVALUE_GETTER(PropertyName) \
            FORCEINLINE float GetMax##PropertyName() const \
            { \
                return PropertyName.GetMaxValue(); \
            }

        #define GAMEPLAYATTRIBUTE_MINVALUE_GETTER(PropertyName) \
            FORCEINLINE float GetMin##PropertyName() const \
            { \
                return PropertyName.GetMinValue(); \
            }

        #define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \
            GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \
            GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \
            GAMEPLAYATTRIBUTE_MAXVALUE_GETTER(PropertyName) \
            GAMEPLAYATTRIBUTE_MINVALUE_GETTER(PropertyName) \
            GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \
            GAMEPLAYATTRUBUTE_VALUE_INITTER(PropertyName)

These are macros that will create functions for you. We don't need the value getter because those are not covered by the macros created in AttributeSet.h. We can't modify that file so its easier to just set it up here.

## Add necessary functions

Next in the FYourGameplayAttributeData struct, add the following code after the "GENERATED_BODY()":

        FYourGameplayAttributeData() : FGameplayAttributeData()
		    , MaxValue(0.f)
		    , MinValue(0.f)
	    {}

	    FYourGameplayAttributeData(float DefaultValue) : FGameplayAttributeData(DefaultValue)
		    , MaxValue(DefaultValue)
		    , MinValue(DefaultValue)
	    {}

	    float GetMaxValue() const;

	    void SetMaxValue(float NewValue);

	    float GetMinValue() const;

	    void SetMinValue(float NewValue);

        protected:
	        UPROPERTY(BlueprintReadOnly, Category = "Attribute")
	        float MaxValue;

	        UPROPERTY(BlueprintReadOnly, Category = "Attribute")
	        float MinValue;

This is just the specification so we will need to implement the functions we defined here in the implementation file, YourAttributeSet.cpp. Go there and add the following code after the constructor and before the "GetYourAbilitySystemComponent" function:

        float FYourGameplayAttributeData::GetMaxValue() const {
	        return MaxValue;
        }

        void FYourGameplayAttributeData::SetMaxValue(float NewValue) {
	        MaxValue = FMath::Max(NewValue, 1.0f); // Max shouldn't be less than 1
        }

        float FYourGameplayAttributeData::GetMinValue() const {
	        return MinValue;
        }

        void FYourGameplayAttributeData::SetMinValue(float NewValue) {
	        MinValue = FMath::Max(NewValue, 0.0f); // Min shouldn't be less than 0
        }

## Add new attributes to data table

Now you have the basics setup, but if you want to be able to update the values of your min and max inside a data table. (You should do it) then you need to override the InitFromMetaDataTable function from AttributeSet.h. Just add the following code and you'll be set:

        void UYourAttributeSet::InitFromMetaDataTable(const UDataTable* DataTable) {
	    static const FString Context = FString(TEXT("UAttribute::BindToMetaDataTable"));

	    for (TFieldIterator<FProperty> It(GetClass(), EFieldIteratorFlags::IncludeSuper); It; ++It)
	    {
		    FProperty* Property = *It;
		    FNumericProperty* NumericProperty = CastField<FNumericProperty>(Property);
		    if (NumericProperty)
		    {
			    FString RowNameStr = FString::Printf(TEXT("%s.%s"), *Property->GetOwnerVariant().GetName(), *Property->GetName());

			    FAttributeMetaData* MetaData = DataTable->FindRow<FAttributeMetaData>(FName(*RowNameStr), Context, false);
			    if (MetaData)
			    {
				    void* Data = NumericProperty->ContainerPtrToValuePtr<void>(this);
				    NumericProperty->SetFloatingPointPropertyValue(Data, MetaData->BaseValue);
			    }
		    }
		    else if (FGameplayAttribute::IsGameplayAttributeDataProperty(Property))
		    {
			    FString RowNameStr = FString::Printf(TEXT("%s.%s"), *Property->GetOwnerVariant().GetName(), *Property->GetName());

			    FAttributeMetaData* MetaData = DataTable->FindRow<FAttributeMetaData>(FName(*RowNameStr), Context, false);
			    if (MetaData)
			    {
				    FStructProperty* StructProperty = CastField<FStructProperty>(Property);
				    check(StructProperty);
				    FYourGameplayAttributeData* DataPtr = StructProperty->ContainerPtrToValuePtr<FYourGameplayAttributeData>(this);
				    check(DataPtr);
				    DataPtr->SetBaseValue(MetaData->BaseValue);
				    DataPtr->SetCurrentValue(MetaData->BaseValue);
				    DataPtr->SetMaxValue(MetaData->MaxValue);
				    DataPtr->SetMinValue(MetaData->MinValue);
			    }
		    }
	    }

	    PrintDebug();
    }

Now you have gameplay attributes with clamping setup and can use it with your gameplay abilities.

# Done
